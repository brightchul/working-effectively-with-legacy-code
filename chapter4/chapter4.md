# 4장 봉합 모델

## 봉합

단위 테스트를 위해 개별 클래스를 추출하려고하면 많은 의존 관계를 제거할 필요가 있다. 


> 봉합지점 : 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말한다. 

레거시 코드를 테스트할 때 가장 큰 문제점 중 하나는 의존 관계를 제거하는 일이다. 봉합지점에서의 동작을 다른 것으로 대체할 수 있다면 테스트할 때 의존 관계를 배제할 수 있다. 


## 봉합의 종류

### 전처리 봉합

컴파일 이전에 빌드의 한 단계를 수행하는 언어에서 가능하다. 
C, C++에서는 컴파일 이전에 매크로 전처리기가 실행된다. 조건부 컴파일 코드, 매크로 등을 이용해서 전처리 봉합을 사용하고 함수 호출을 대체할 수 잇다. 

> 활성화 지점 : 모든 봉합은 활성화 지점을 갖는다. 활성화 지점에서는 어느 동작을 사용할지 선택할 수 있다. 

### 링크 봉합

컴파일러는 코드의 중간 표현을 생성하며, 이 중간 표현은 다른 파일에 들어 있는 코드를 호출한다. 링커는 이러한 중간 표현들을 조합한다. 

C, C++ 에서는 이와 같은 작업을 수행하는 링커가 별도로 존재한다. 여기서 링크 봉합 기법을 사용해 프로그램의 일부를 대체할 수 있다. 자바의 경우 CLASSPATH 환경 변수를 사용해 클래스를 찾을 위치를 지정할 수 있다.

링크 봉합의 활성화 지점은 언제나 소스 코드의 외부에 위치한다. 빌드 스크립트나 배치 스크립트 내부에 위치할 때도 있기 때문에 리읔 봉합을 사용하고 있음을 알아차리기 어려울 때가 있다. 

> 링크 봉합을 사용할 때는 테스트 환경과 제품/배포 환경 간에 분명한 차이가 있도록 구성해야 한다. 

### 객체 봉합

객체지향 프로그램의 경우, 호출 위치의 코드를 들여다봐도 실제로 어떤 메소드가 실행될지 정의되어 있지 않다. 

메서드 안에서 어떠한 객체의 메서드를 호출할 지라도 반드시 봉합지점이 되는 것은 아니다.

```typescript 

buildMartSheet() {
  // 생략 ..
  const cell = new FormulaCell(this, "A1", "=A2+A3);
  // 생략 ..
  cell.Recalculate();
  // 생략 ..
}

```

이런 경우 buildMartSheet 메서드 안에서 cell변수의 클래스가 FormulaCell로 고정되기 때문이다. 해당 메서드를 수정하지 않으면 cell 클래스를 변경할 수가 없다. 반면에 아래와 같이 하면 메서드 수정없이 변경이 가능하다.


```typescript 

buildMartSheet(cell : Cell) {
  // 생략 ..
  cell.Recalculate();
  // 생략 ..
}

```

buildMartSheet를 호출하면서 Cell의 어떠한 객체를 인자로 전달하면 되기 때문이다. 
여기서 활성화 지점은 buildMartSheet의 인수 인스트이다. 어떤 종류의 객체를 전달하느냐에 따라서 buildMartSheet의 메서드 동작이 변경될 수 있기 때문이다. 

상당히 복잡한 레거시 코드일 경우에는 테스트 루틴을 작성할 때 코드 수정을 최소화하는 점진적인 접근이 바람직하다. 

테스트를 수행할 때 적절한 종류의 봉합을 선택하는 것은 중요한 일이다. 일반적으로 객체 봉합은 객체지향 언어에서 가장 적합한 방법이다. 
전처리 봉합과 링크 봉합에 의존하는테스트 루틴은 관리하기도 매우 어렵다. 
# 3장 감지와 분리 

클래스들 간에 의존 관계가 존재하기 때문에 특정 객체들만 테스트 루틴으로 보호하는 것은 매우 어려울 때가 많다. 어떤 클래스의 객체를 생성해 어떤 식으로 사용하고 싶은데, 다른 클래스의 객체가 필요하고, 다시 또다른 객체가 필요한게 반복되면 시스템의 많은 부분들이 테스트 내부에 포함되는 상황이 벌어지기도 한다. 


테스트 루틴을 배치할 때 의존 관계를 제거하는 이유
1. 감지 : 코드 내에서 계산된 값에 접근할 수 없을 때, 이를 감지하기 위해 의존 관계를 제거한다. 
2. 분리 : 코드를 테스트 하네스 내에 넣어서 실행할 수 없을 때, 코드를 분리하기 위해 의존관계를 제거한다.

감지와 분리 중 어느쪽이 더 어려운 문제인지는 명확한 답이 없다. 일반적으로 감지와 분리 모두 필요하며, 둘 다 의존 관계를 제거하는 이유가 된다. 

분리에 사용되는 기법은 매우 다양하다. 반면에 감지의 경우에는 거의 언제가 다음 기법을 사용한다. 

## 협업 클래스 위장하기

레거시 코드를 다룰 때의 가장 큰 문제 중 하나가 의존 관계다. 특정 코드만 독립적으로 실행해 어떻게 동작하는지 테스트하려면, 대체로 다른 코드에 대한 의존 관계를 제거할 필요가 있다. 의존 하는 다른 코드를 별도의 코드로 대체할 수만 있다면 변경 대상을 테스트하는 루틴을 작성할 수 있을 것이다. 

객체지향 프로그래밍에서는 이 별도의 코드를 가리켜서 가짜 객체 혹은 fake object라고 부른다. 

### 가짜 객체 

각짜 객체란 어떤 클래스를 테스트할 때 그클래스의 협업 클래스를 모방하는 객체를 말한다. 

예를 들어서 Sale이란 클래스가 있다. 여기서 디스플레이 역할을 하는 ArtR56Display 클래스를 추가한다. 이렇게 디스플레이 클래스를 분리해서 이후에 FakeDisplay클래스와도 통신할 수 있게 되며 테스트 루틴을 작성할 수 있다. Sale객체는 생성자를 통해 디스플레이를 전달받고 내부적으로 이를 유지할 수 있다. 

```typescript

export class Sale {
  private display: Display;
  private itemMap: Map<string, Item>;

  constructor(display: Display, itemList: Item[]) {
    this.display = display;
    // 생략 
  }

  // 생략 
}
```

Display 인터페이스로 Sale에 전달할 수 잇는 디스플레이 객체가 다양해졌다. FakeDisplay를 전달할 것이고 여기서 getLastLine 메소드를 이용해서 텍스트가 제대로 전달되는지 확인할 수 있다. 

```typescript
class FakeDisplay implements Display {
  private lastLine = "";

  public showLine(line: string) {
    this.lastLine = line;
  }
  public getLastLine() {
    return this.lastLine;
  }
}
```

> 가짜 객체가 진짜 테스트를 지원한다. 
> 테스트 루틴을 작성할 때 분할후 정복 접근법을 취해야 한다. 버그의 원인이 특정 클래스에 있는지 여부를 확인할 수 있기 때문이다. 이러한 테스트를 통해 오류의 원인이 발생한 위치를 좁혀나가고 디버깅 시간을 절약할 수 있다. 


### 가짜 객체의 양면성 

가짜 객체는 양면성을 가진다. 

FakeDisplay 클래스는 Display 인터페이스르 구현하기 때문에 showLine 메소드가 필요하다. 이것은 Sale 클래스가 바라보는 유일한 메소드이다. getLastLine은 테스트용이며 이것을 이용해 우리는 내용을 확인할 수 있다. 

### 가짜 객체의 핵심

다양한 방식으로 가짜 객체가 구현될 수 있다. 
- 객체지향 언어에서는 간단한 클래스를 사용해서 구현한다. 
- 객체지향이 아닌 언어에서는 대체함수는 정의해서 구현한다. (19장 참조)

### 모조 객체

만일 가짜 객체를 많이 사용해야 한다면 가짜 객체가 발전된 모조 객체 mock object를 사용해도 된다. 
모조 객체란 내부적으로 검증을 수행하는 가짜 객체를 말한다. 

모조 객체의 장점은 예상되는 메소드 호출을 모조 객체에 미리 알려주고, 메소드가 호출됐는지 검증하도록 지시할 수 있다는 점이다.

모조 객체는 강력한 도구이지만, 모든 언어에서 사용가능한 것은 아니며, 대부분의 경우 간단한 가짜 객체만으로도 충분하다.
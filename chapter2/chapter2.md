# 2장 피드백 활용

시스템을 변경하는 방법은 2가지로 나눌수 있다.
- 편집 후 기도하기
- 보호 후 수정하기

### 편집 후 기도하기

변경 완료 후에 시스템을 실행해서 변경 사항이 제대로 동작하고 모언가 손상된 동작이 없는지 자세히 조사한다. 그러나 아무리 신중하게 주의를 기울여도 안전성이 높아진다는 보장은 없다. 주의를 기울여 작업하더라도 적절한 도구와 기법이 없다면 효과를 거두기 어렵다. 


### 보호 후 수정하기

이 방식의 기본 개념은 소프트웨어를 변경할 때 '안전망'을 이용하자는 것이다. 여기서 안전망이란 테스트 루틴으로 코드를 커버해서 변경에 따른 문제가 발생해도 이로 인해 나머지 코드에 미치는 영향을 최소화하는 것을 의미한다. 테스트 루틴으로부터 피드백을 받을 수 있기 때문에 더욱 신중하게 변경을 수행할 수 있다.

QA팀의 테스트는 '작업 결과의 정확성을 보여주기 위한 테스트'이다. 이러한 전통적인 테스트를 회귀 테스트라고 불러왔다. 회귀 테스트란 주기적으로 테스트를 실행해 정상적인 동작 여부를 확인하고 지금까지와 마찬가지로 소프트웨어가 동작하는지 조사하는 것을 의미한다. 

회귀 테스트에는 문제가 있다. QA 팀으로부터 회귀 테스트를 실행하면 시간이 다소 많이 걸리고, 테스트를 통과하지 못했을 때 그 원인을 빠르게 파악하기가 어렵다. 

시스템 수준의 회귀 테스트는 중요하지만, 소규모 수준의 부분별 테스트도 중요하다. 개발 과정에서 빠른 피드백을 제공해서 훨씬 더 안전한 리팩토링이 가능하기 때문이다. 


## 단위 테스트란? 

단위 테스트의 기본 개념은 독립된 개별 소프트웨어 컴포넌트를 테스트하는 것이다. 
컴포넌트란 시스템의 가장 원자적인 동작 단위를 의미한다. 절차적 프로그래밍에서는 함수, 객체 지향 프로그래밍에서는 클래스를 의미한다 .
함수나 클래스의 분리 테스트는 단위 테스트의 의미상 매우 중요하다. 

### 대규모 테스트의 문제점

- 오류 위치 파악 : 테스트 루틴이 테스트 대상으로부터 멀어지면 멀어질수록, 테스트 실패가 의미하는 바를 파악하기 힘들어져서 테스트 실패 발생 지점을 찾기가 어려워진다. 
- 실행 시간 : 테스트 루틴의 길이가 길어질수록 실행하는데 오랜 시간이 걸린다. 
- 커버리지 : 코드 조각과 그 코드 조각을 실행시키는 값들의 연결 관계는 파악하기 어렵다. 

> 테스트 루틴이 대규모일 경우에는 실행 시간이 지나치게 길어지기 때문에 오류 위치를 파악하기 위한 테스트 실행을 회피하기 쉽다. 

단위 테스트는 대규모 테스트의 단점을 보완할 수 있다. 

### 좋은 단위 테스트의 조건

1. 실행 속도가 빠르다.
2. 오류 위치 파악에 도움이 된다.

> 실행에 0.1초가 걸리는 단위 테스트는 속도가 느린 단위테스트이다. 

> 단위 테스트는 실행속도가 빨라야 한다. 실행 속도가 빠르지 않다면 단위 테스트가 아니다. 
> 다음은 단위 테스트가 아닌 테스트들이다.
> 1. DB와 연동한다.
> 2. 네트워크를 통해 통신한다.
> 3. 파일 시스템을 건드린다.
> 4. 테스트 실행을 위해 특별한 작업을 해야 한다. 


## 상위 수준의 테스트 

상위 수준의 테스트를 통해 우리는 다수 클래스들의 동작을 한 번에 확인할 수 있다. 


## 테스트를 통한 코드 보호

변경을 가할 코드 주위에 테스트 루틴을 배치하는 것이 언제나 안전성을 높여준다. 이후 변경을 가했을 때 발생한 오류를 좀 더 쉽게 잡아낼 수 있다.

테스트하기 어려운 무언가에 직접 의존하는 클래스느 다루거나 수정하기가 어렵다. 

> 의존 관계는 소프트웨어 개발에서 가장 중요한 문제 중 하나이다. 대부분의 레거시 코드 작업은 코드를 좀 더 쉽게 변경할 수 있도록 의존 관계를 제거하는 가업을 포함한다.

> 레거시 코드의 딜레마
> 코드 변경을 하려면 테스트 코드를 배치해야 한다. 그런데 테스트 코드를 배치하려면 코드 변경이 필요할 떄가 많다. 

특정 클래스를 변경하지 않고 테스트 루틴을 작성하기 어렵다면, 그 클래스를 사용하는 상위 클래스를 테스트하는 것이 더 쉽다. 

오류를 일으킬 가능성이 있을 때는 보수적으로 리팩토링을 진행하는 것이 올바른 접근법이다. 

> 레거시 코드에서 의존 관계를 제거할 때는 미적인 감각을 다소 내려놓아야 한다. 깨끗하게 제거되는 의존 관계도 있지만, 어떤 경우에는 디자인 관점에서 그다지 바람직해 보이지 않는 코드 결과물이 나올 수도 있다. 의존 관계를 제거한 지점 주위에 나중에 코드를 보호하는 테스트를 작성해서 이 흉터도 제거할 수 있게 된다.


## 레거시 코드를 변경하는 순서

1. 변경 지점을 식별한다.
2. 테스트 루틴을 작성할 위치를 찾는다.
3. 의존 관계를 제거한다. 
4. 테스트 루틴을 작성한다. 
5. 변경 및 리팩토링을 수행한다. 


### 변경 지점을식별한다. 

코드 변경을 수행할 지점은 소프트웨어 아키텍처와 밀접한 연관이 있다. 설계를 잘 모른다면 16장, 17장을 참조하자. 


### 테스트 루틴을 작성할 위치를 찾는다.

테스트 루틴을 작성할 위치를 찾기 어렵다면 11장과 12장을 읽어보면 도움이 될 것이다. 


### 의존 관계를 제거한다. 

의존 관계는 테스트 실행에 있어 가장 큰 장애물이다. 의존 관계가 문제가 되는 가장 대표적인 두 가지 경우는 테스트 하네스 내부에서의 객체 인스턴스 생성과 메소드 실행이다. 레거시 코드를 다룰 때는 테스트 루틴을 배치하기 위해 의존 관계를 제거해야 할 때가 많은데 이것에 대한 여파를 확인할 테스트 루틴이 대부분 존재하지 않는다. 테스트를 통해 시스템을 보호할 때 최초의 작업을 수행하는 실용적인 기법은 23장, 의존 관계 제거 기법에 대한 지식은 25장 기법 목록을 읽어보자.

### 테스트 루틴을 작성한다. 

레거시 코드에서 작성하는 테스트 루틴은 신규 코드에 대한 테스트 루틴과는 다른 점이 있다. 레거시 코드에서 테스트가 맡은 역할에 대해서는 13장을 참조하자. 

### 변경 및 리팩토링을 수행한다. 

TDD 방법론을 권장하는데 이것은 8장에 소개되어 있다. 20~22장까지는 레거시 코드의 구조를 개선할 수 있는 기초적인 기법들을 설명한다. 
